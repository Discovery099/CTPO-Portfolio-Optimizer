"""\nIntegration tests for 2020 COVID Crash\n\nValidates CTPO performance during rapid volatility spike\n"""\n\nimport pytest\nimport numpy as np\nimport pandas as pd\nimport sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\n\nfrom ctpo.data.fetcher import DataFetcher\nfrom ctpo.core.optimizer import CTPOOptimizer\nfrom ctpo.metrics.performance import PerformanceMetrics\n\nCOVID_SYMBOLS = [\n    'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA',\n    'NVDA', 'META', 'JPM', 'V', 'WMT'\n]\n\n@pytest.fixture(scope='module')\ndef covid_data():\n    \"\"\"Fetch 2020 COVID period data\"\"\"\n    print(\"\\nðŸ”„ Fetching 2020 COVID crash data...\")\n    \n    fetcher = DataFetcher()\n    \n    try:\n        returns_df = fetcher.fetch_returns(\n            COVID_SYMBOLS,\n            start_date='2020-01-01',\n            end_date='2020-12-31'\n        )\n        \n        if returns_df.empty or len(returns_df) < 100:\n            pytest.skip(\"Insufficient COVID data available\")\n        \n        print(f\"âœ… Fetched {len(returns_df)} days of data for {len(returns_df.columns)} assets\")\n        return returns_df\n        \n    except Exception as e:\n        pytest.skip(f\"Could not fetch COVID data: {e}\")\n\n\n@pytest.mark.integration\n@pytest.mark.slow\n@pytest.mark.crisis\nclass TestCrisis2020Performance:\n    \"\"\"Validate performance during COVID crash\"\"\"\n    \n    def test_rapid_recovery(self, covid_data):\n        \"\"\"Test that CTPO recovers faster than baseline\"\"\"\n        optimizer = CTPOOptimizer()\n        returns = covid_data.values\n        \n        # CTPO\n        weights_ctpo = optimizer.optimize(returns)\n        portfolio_returns_ctpo = returns @ weights_ctpo\n        return_ctpo = PerformanceMetrics.total_return(portfolio_returns_ctpo)\n        \n        # Baseline\n        n_assets = returns.shape[1]\n        weights_ew = np.ones(n_assets) / n_assets\n        portfolio_returns_ew = returns @ weights_ew\n        return_ew = PerformanceMetrics.total_return(portfolio_returns_ew)\n        \n        print(f\"\\nðŸ“ˆ 2020 Recovery:\")\n        print(f\"   CTPO Return: {return_ctpo:.2%}\")\n        print(f\"   Equal-Weight Return: {return_ew:.2%}\")\n        \n        assert return_ctpo > return_ew, \\\n            \"CTPO should recover faster post-crash\"\n    \n    def test_volatility_handling(self, covid_data):\n        \"\"\"Test performance during extreme volatility\"\"\"\n        optimizer = CTPOOptimizer()\n        returns = covid_data.values\n        \n        weights = optimizer.optimize(returns)\n        portfolio_returns = returns @ weights\n        \n        # Check volatility\n        vol = PerformanceMetrics.volatility(portfolio_returns)\n        sharpe = PerformanceMetrics.sharpe_ratio(portfolio_returns)\n        \n        print(f\"\\nðŸ“Š Volatility Metrics:\")\n        print(f\"   Portfolio Volatility: {vol:.2%}\")\n        print(f\"   Sharpe Ratio: {sharpe:.3f}\")\n        \n        # Should maintain positive Sharpe despite volatility\n        assert sharpe > 0, \"Should maintain positive risk-adjusted returns\"\n\n\nif __name__ == '__main__':\n    pytest.main([__file__, '-v', '-s'])\n