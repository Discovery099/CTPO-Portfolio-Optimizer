"""\nIntegration tests for 2008 Financial Crisis\n\nValidates CTPO performance during extreme market stress\n"""\n\nimport pytest\nimport numpy as np\nimport pandas as pd\nimport sys\nfrom pathlib import Path\nimport warnings\n\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\n\nfrom ctpo.data.fetcher import DataFetcher\nfrom ctpo.core.optimizer import CTPOOptimizer\nfrom ctpo.metrics.performance import PerformanceMetrics\n\n# Test with representative stocks from 2007\nCRISIS_SYMBOLS = [\n    'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'JPM', \n    'BAC', 'GE', 'XOM', 'CVX', 'WMT',\n    'PG', 'JNJ', 'KO', 'PFE', 'T'\n]\n\n@pytest.fixture(scope='module')\ndef crisis_data():\n    \"\"\"Fetch 2008 crisis period data\"\"\"\n    print(\"\\nüîÑ Fetching 2008 crisis data (this may take a few minutes)...\")\n    \n    fetcher = DataFetcher()\n    \n    try:\n        # Try to fetch data for crisis period\n        returns_df = fetcher.fetch_returns(\n            CRISIS_SYMBOLS[:10],  # Use subset for speed\n            start_date='2007-01-01',\n            end_date='2009-12-31'\n        )\n        \n        if returns_df.empty or len(returns_df) < 100:\n            pytest.skip(\"Insufficient crisis data available\")\n        \n        print(f\"‚úÖ Fetched {len(returns_df)} days of data for {len(returns_df.columns)} assets\")\n        return returns_df\n        \n    except Exception as e:\n        pytest.skip(f\"Could not fetch crisis data: {e}\")\n\n\n@pytest.mark.integration\n@pytest.mark.slow\n@pytest.mark.crisis\nclass TestCrisis2008Performance:\n    \"\"\"Validate performance during 2008 financial crisis\"\"\"\n    \n    def test_crisis_optimization_runs(self, crisis_data):\n        \"\"\"Test that optimization runs successfully on crisis data\"\"\"\n        optimizer = CTPOOptimizer()\n        returns = crisis_data.values\n        \n        weights = optimizer.optimize(returns)\n        \n        assert weights is not None\n        assert len(weights) == returns.shape[1]\n        assert np.isclose(weights.sum(), 1.0, atol=1e-3)\n    \n    def test_sharpe_ratio_calculation(self, crisis_data):\n        \"\"\"Test Sharpe ratio during crisis\"\"\"\n        optimizer = CTPOOptimizer()\n        returns = crisis_data.values\n        \n        # CTPO optimization\n        weights_ctpo = optimizer.optimize(returns)\n        portfolio_returns_ctpo = returns @ weights_ctpo\n        sharpe_ctpo = PerformanceMetrics.sharpe_ratio(portfolio_returns_ctpo)\n        \n        # Equal-weight baseline\n        n_assets = returns.shape[1]\n        weights_ew = np.ones(n_assets) / n_assets\n        portfolio_returns_ew = returns @ weights_ew\n        sharpe_ew = PerformanceMetrics.sharpe_ratio(portfolio_returns_ew)\n        \n        improvement = sharpe_ctpo - sharpe_ew\n        \n        print(f\"\\nüìä Sharpe Ratios:\")\n        print(f\"   CTPO: {sharpe_ctpo:.3f}\")\n        print(f\"   Equal-Weight: {sharpe_ew:.3f}\")\n        print(f\"   Improvement: {improvement:.3f}\")\n        \n        # Target: >= 0.15 improvement\n        assert sharpe_ctpo > sharpe_ew, \\\n            f\"CTPO Sharpe ({sharpe_ctpo:.3f}) should exceed baseline ({sharpe_ew:.3f})\"\n        \n        if improvement >= 0.15:\n            print(\"‚úÖ PASSED: Sharpe improvement >= 0.15\")\n        else:\n            print(f\"‚ö†Ô∏è  WARNING: Sharpe improvement {improvement:.3f} < 0.15 target\")\n    \n    def test_drawdown_reduction(self, crisis_data):\n        \"\"\"Test maximum drawdown reduction\"\"\"\n        optimizer = CTPOOptimizer()\n        returns = crisis_data.values\n        \n        # CTPO optimization\n        weights_ctpo = optimizer.optimize(returns)\n        portfolio_returns_ctpo = returns @ weights_ctpo\n        dd_ctpo = abs(PerformanceMetrics.max_drawdown(portfolio_returns_ctpo))\n        \n        # Equal-weight baseline\n        n_assets = returns.shape[1]\n        weights_ew = np.ones(n_assets) / n_assets\n        portfolio_returns_ew = returns @ weights_ew\n        dd_ew = abs(PerformanceMetrics.max_drawdown(portfolio_returns_ew))\n        \n        reduction = (dd_ew - dd_ctpo) / dd_ew if dd_ew > 0 else 0\n        \n        print(f\"\\nüìâ Maximum Drawdowns:\")\n        print(f\"   CTPO: {dd_ctpo:.2%}\")\n        print(f\"   Equal-Weight: {dd_ew:.2%}\")\n        print(f\"   Reduction: {reduction:.2%}\")\n        \n        # Target: >= 25% reduction\n        assert dd_ctpo <= dd_ew, \\\n            f\"CTPO drawdown ({dd_ctpo:.2%}) should be less than baseline ({dd_ew:.2%})\"\n        \n        if reduction >= 0.25:\n            print(\"‚úÖ PASSED: Drawdown reduction >= 25%\")\n        else:\n            print(f\"‚ö†Ô∏è  WARNING: Drawdown reduction {reduction:.2%} < 25% target\")\n    \n    def test_positive_return(self, crisis_data):\n        \"\"\"Test that CTPO maintains capital during crisis\"\"\"\n        optimizer = CTPOOptimizer()\n        returns = crisis_data.values\n        \n        weights = optimizer.optimize(returns)\n        portfolio_returns = returns @ weights\n        \n        total_return = PerformanceMetrics.total_return(portfolio_returns)\n        annual_return = PerformanceMetrics.annualized_return(portfolio_returns)\n        \n        print(f\"\\nüí∞ Returns:\")\n        print(f\"   Total Return: {total_return:.2%}\")\n        print(f\"   Annualized Return: {annual_return:.2%}\")\n        \n        # Should at least beat equal-weight\n        n_assets = returns.shape[1]\n        weights_ew = np.ones(n_assets) / n_assets\n        portfolio_returns_ew = returns @ weights_ew\n        total_return_ew = PerformanceMetrics.total_return(portfolio_returns_ew)\n        \n        assert total_return >= total_return_ew, \\\n            \"CTPO should outperform equal-weight during crisis\"\n\n\nif __name__ == '__main__':\n    pytest.main([__file__, '-v', '-s'])\n