"""\nComprehensive unit tests for CTPOOptimizer\n"""\n\nimport pytest\nimport numpy as np\nimport sys\nfrom pathlib import Path\n\n# Add project root to path\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\n\nfrom ctpo.core.optimizer import CTPOOptimizer, CTPOState\n\n@pytest.fixture\ndef optimizer():\n    \"\"\"Create optimizer instance for testing\"\"\"\n    return CTPOOptimizer()\n\n@pytest.fixture\ndef mock_returns():\n    \"\"\"Generate synthetic return data\"\"\"\n    np.random.seed(42)\n    n_assets = 10\n    n_periods = 252\n    \n    # Generate returns with reasonable statistics\n    returns = np.random.normal(0.0005, 0.02, (n_periods, n_assets))\n    return returns\n\n@pytest.mark.unit\nclass TestOptimizerCore:\n    \"\"\"Core optimization tests\"\"\"\n    \n    def test_convergence_time(self, optimizer, mock_returns):\n        \"\"\"Test that optimization completes within 50ms\"\"\"\n        import time\n        \n        start = time.perf_counter()\n        weights = optimizer.optimize(mock_returns)\n        elapsed_ms = (time.perf_counter() - start) * 1000\n        \n        assert elapsed_ms < 50, \\\n            f\"Solve time {elapsed_ms:.1f}ms exceeds 50ms limit\"\n    \n    def test_weights_sum_to_one(self, optimizer, mock_returns):\n        \"\"\"Test capital conservation constraint\"\"\"\n        weights = optimizer.optimize(mock_returns)\n        \n        assert np.isclose(weights.sum(), 1.0, atol=1e-3), \\\n            f\"Weights sum to {weights.sum():.6f}, not 1.0\"\n    \n    def test_position_limits(self, optimizer, mock_returns):\n        \"\"\"Test individual position constraints\"\"\"\n        weights = optimizer.optimize(mock_returns)\n        \n        # Long-only\n        assert np.all(weights >= -1e-6), \\\n            f\"Min weight {weights.min():.6f} violates non-negativity\"\n        \n        # Reasonable max\n        n_assets = len(weights)\n        max_allowed = max(0.5, 1.5 / n_assets)\n        assert np.all(weights <= max_allowed + 1e-2), \\\n            f\"Max weight {weights.max():.4f} exceeds limit\"\n    \n    def test_effective_assets(self, optimizer, mock_returns):\n        \"\"\"Test minimum diversification\"\"\"\n        weights = optimizer.optimize(mock_returns)\n        \n        enp = 1.0 / np.sum(weights ** 2) if np.sum(weights ** 2) > 0 else 0\n        \n        # Should maintain reasonable diversification\n        assert enp >= 2.0, \\\n            f\"Effective assets {enp:.1f} too low\"\n    \n    def test_leverage_limit(self, optimizer, mock_returns):\n        \"\"\"Test leverage constraint\"\"\"\n        weights = optimizer.optimize(mock_returns)\n        \n        leverage = np.sum(np.abs(weights))\n        assert leverage <= 2.0, \\\n            f\"Leverage {leverage:.2f} exceeds maximum\"\n    \n    def test_not_equal_weight_fallback(self, optimizer, mock_returns):\n        \"\"\"Test that optimizer produces optimized weights\"\"\"\n        weights = optimizer.optimize(mock_returns)\n        \n        # Check variance - should not be all equal\n        weight_std = np.std(weights)\n        assert weight_std > 0.01, \\\n            f\"Weights too uniform (std={weight_std:.4f}), possible fallback\"\n\n\n@pytest.mark.unit\nclass TestNumericalStability:\n    \"\"\"Numerical stability tests\"\"\"\n    \n    def test_small_portfolio(self, optimizer):\n        \"\"\"Test with 3 assets\"\"\"\n        np.random.seed(42)\n        returns = np.random.normal(0.0005, 0.02, (100, 3))\n        \n        weights = optimizer.optimize(returns)\n        \n        assert len(weights) == 3\n        assert np.isclose(weights.sum(), 1.0, atol=1e-3)\n        assert np.all(weights >= 0)\n    \n    def test_large_portfolio(self, optimizer):\n        \"\"\"Test with 50 assets\"\"\"\n        np.random.seed(42)\n        returns = np.random.normal(0.0005, 0.02, (252, 50))\n        \n        weights = optimizer.optimize(returns)\n        \n        assert len(weights) == 50\n        assert np.isclose(weights.sum(), 1.0, atol=1e-3)\n    \n    def test_high_correlation_scenario(self, optimizer):\n        \"\"\"Test with highly correlated assets\"\"\"\n        np.random.seed(42)\n        n_assets = 10\n        n_periods = 252\n        \n        # Create correlated returns\n        base = np.random.normal(0.0005, 0.02, n_periods)\n        returns = np.column_stack([\n            base + np.random.normal(0, 0.005, n_periods)\n            for _ in range(n_assets)\n        ])\n        \n        weights = optimizer.optimize(returns)\n        \n        assert np.isclose(weights.sum(), 1.0, atol=1e-3)\n        assert np.all(weights >= 0)\n\n\n@pytest.mark.unit\nclass TestStressActivation:\n    \"\"\"Test stress mode functionality\"\"\"\n    \n    def test_stress_level_computation(self, optimizer):\n        \"\"\"Test stress activation computation\"\"\"\n        alpha_low = optimizer._compute_stress_level(0.10)\n        alpha_high = optimizer._compute_stress_level(0.40)\n        \n        assert 0 <= alpha_low <= 1\n        assert 0 <= alpha_high <= 1\n        assert alpha_high > alpha_low\n\n\nif __name__ == '__main__':\n    pytest.main([__file__, '-v'])\n